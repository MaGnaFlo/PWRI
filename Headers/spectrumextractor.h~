/*!
 * Author : Florian Lardeux, Thomas Maifret, Victor Petitjean
 * November 2015
 * 
 * The class SpectrumExtractor is the tool used to calculate the spectrum from raw data.
 * From a set of images, it can return the spectrum over the entire image, over a region
 * of interest, or for each pixel (filtered)
*/

#ifndef SPECTRUMEXTRACTOR_H
#define SPECTRUMEXTRACTOR_H

#include <opencv2/core/core.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <iostream>
#include <vector>
#include <iomanip>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <QProgressBar>

#include "operation.h"
#include "dataanalyzer.h"

class SpectrumExtractor
{
public:
    //Constructors
    SpectrumExtractor();
    SpectrumExtractor(int imgStart, int imgEnd, double angleStart, double angleStep, std::string path, std::string name, std::string ext);

    //Setter & getter for _dataBlock
    /*!
     * With these methods, we can get one point of one spectrum, or one whole spectrum
    */
    double getDataBlock(const int x, const int y, const int i);
    std::vector<double> getDataBlockSpectre(const int x, const int y);
    void setDataBlock(const int x, const int y, const int i, const double value);

    //Processes

    /*!
     * Amongst these processes, only processSpectrumAverage and processSpectrumAllPixels
     * should be used outside of the class !
    */

    /*!
     * processSpectrumAverage returns the mean spectrum of an entire image.
     * We can give it a pointer on a progress bar Qt, to update it while processing
    */
    void processSpectrumAverage(QProgressBar *progressBar);

    /*!
     * processSpectrumZone returns the mean spectrum over a certain rectangular region,
     * defined by its top-left corner, its width and its height.
    */
    void processSpectrumZone(int width, int height, int posX, int posY);

    /*!
     * processSpectrumPixelBlock returns _dataBlock, which contains all the spectrum per pixel over a square
     * of size _sizeBlock
    */
    void processSpectrumPixelBlock(int posBlockX, int posBlockY);

    /*!
     * processSpectrumAllPixels returns two images that correspond to the first and second minimum of
     * the spectrum over each pixel. The grey value of the images is directly linkable to the angle
     * at which it appears (P or s resonance)
    */
    void processSpectrumAllPixels(QProgressBar *progressBar);

    /*!
     * borderCorrect
     * noBorderProcessing
     * indexing
     * initAndProcessing
     * These methods are used in the previous methods. You are not supposed to use them. Sorry !
    */
    int borderCorrect(int x, int y);
    void noBorderProcessing(std::vector<double> filter, int posBlockX, int posBlockY);
    void indexing(std::vector<double> filter, int posBlockX, int posBlockY);
    void initAndProcess(int posBlockX, int posBlockY);


    //Getters
    std::vector<double> dataX() const;
    std::vector<double> dataY() const;
    //std::vector<std::vector<double> > dataZ() const;
    std::vector<double> dataBlock() const;

    cv::Mat getMinP() const;
    cv::Mat getMinS() const;


private :
    std::vector<double> _dataX;
    std::vector<double> _dataY;
    //std::vector< std::vector<double> > _dataZ;
    std::vector<double> _dataBlock;

    cv::Mat _minP;
    cv::Mat _minS;

    std::string _pathS;
    std::string _ext;
    std::string _name;
    Operation _op;
    double _angleStart;
    double _angleStep;
    unsigned int _imgStart;
    unsigned int _imgEnd;
    unsigned int _width;
    unsigned int _height;
    unsigned int _sizeBlock;
};

#endif // SPECTRUMEXTRACTOR_H
